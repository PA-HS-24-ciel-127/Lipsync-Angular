/**Auto-generated by: https://github.com/angular-threejs/gltf
Command: npx angular-three-gltf&#64;1.0.9 public/walky_talky_2.glb -o src/app/experience/avatar_2.ts --selector avatar --transform
**/

import type * as THREE from 'three'
import { Bone, Group, SkinnedMesh, Mesh } from 'three'
import {
  extend,
  injectBeforeRender,
  NgtGroup,
  NgtObjectEvents,
  NgtObjectEventsInputs,
  NgtObjectEventsOutputs,
  NgtArgs,
} from 'angular-three'
import {
  Component,
  ChangeDetectionStrategy,
  CUSTOM_ELEMENTS_SCHEMA,
  signal,
  Signal,
  input,
  viewChild,
  ElementRef,
  inject,
  effect,
  computed,
  model,
} from '@angular/core'
import { injectFBX, injectGLTF } from 'angular-three-soba/loaders'
import { GLTF } from 'three-stdlib'
import { injectAnimations } from 'angular-three-soba/misc'
import { playAudio } from '../play-audio';
import lipSync from './nx-cloud-speech.json';

type ActionName =
  | 'metarig.001|mixamo.com|Layer0'
  | 'new idle by jasmin'
  | 'wave'
  | 'wave new by jasmin'
  | 'BodyAction'
  | 'Wave'
type GLTFResult = GLTF & {
  nodes: {
    Head: THREE.Mesh
    left_eyebrow: THREE.Mesh
    left_eye: THREE.Mesh
    right_eye: THREE.Mesh
    right_eyebrow: THREE.Mesh
    Body: THREE.SkinnedMesh
    spine: THREE.Bone
  }
  materials: {
    ['Material.001']: THREE.MeshStandardMaterial
    Material_0: THREE.MeshStandardMaterial
  }
}

const mouthCuesMap: Record<string, string> = {
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  E: "E",
  F: "F",
  G: "A",
  H: "A",
  X: "",
};

@Component({
  selector: 'app-avatar',
  standalone: true,
  template: `
    @if (gltf(); as gltf) {
      <ngt-group #model [parameters]="options()">
        <ngt-group name="Scene">
          <ngt-group name="metarig" [rotation]="[-0.12, 0.1, 0.04]">
            <ngt-primitive *args="[gltf.nodes.spine]" />
            <ngt-skinned-mesh
              name="Body"
              [geometry]="gltf.nodes.Body.geometry"
              [material]="gltf.materials.Material_0"
              [skeleton]="gltf.nodes.Body.skeleton" />
          </ngt-group>
        </ngt-group>

        <ng-content />
      </ngt-group>
    }
  `,
  imports: [NgtArgs],
  hostDirectives: [
    {
      directive: NgtObjectEvents,
      inputs: NgtObjectEventsInputs,
      outputs: NgtObjectEventsOutputs,
    },
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Avatar {
  protected readonly Math = Math

  options = input({} as Partial<NgtGroup>)
  animations = model<any>()
  modelRef = viewChild<ElementRef<Group>>('model')
  boneRef = viewChild<ElementRef<Bone>>('bone');

  protected gltf = injectGLTF(() => '/walky_talky-transformed.glb', {
    useDraco: true,
  }) as unknown as Signal<GLTFResult | null>

  private scene = computed(() => {
    const gltf = this.gltf()
    if (!gltf) return null
    return gltf.scene
  })

  private objectEvents = inject(NgtObjectEvents, { host: true })

  constructor() {
    extend({ Group, SkinnedMesh, Mesh })

    const animations = injectAnimations(this.gltf, this.scene)
    effect(
      () => {
        if (animations.ready()) {
          this.animations.set(animations)
        }
      },
      { allowSignalWrites: true },
    )

    const audio = new Audio('/nx-cloud-speech.mp3');

    injectBeforeRender(() => {
      const gltf = this.gltf();
      if (!gltf) return;

      if (!playAudio()) return;

      if (!('mouthCues' in lipSync)) return;

      const head = gltf.nodes.Head;
      const left_eye = gltf.nodes.left_eye;
      const right_eye = gltf.nodes.right_eye;
      const left_eyebrow = gltf.nodes.left_eyebrow;
      const right_eyebrow = gltf.nodes.right_eyebrow;

      if (
        !head.morphTargetInfluences ||
        !head.morphTargetDictionary ||
        !left_eye.morphTargetDictionary ||
        !left_eye.morphTargetInfluences ||
        !right_eye.morphTargetDictionary ||
        !right_eye.morphTargetInfluences ||
        !left_eyebrow.morphTargetDictionary ||
        !left_eyebrow.morphTargetInfluences ||
        !right_eyebrow.morphTargetDictionary ||
        !right_eyebrow.morphTargetInfluences
      )
        return;

      const { morphTargetDictionary: headTargetDictionary, morphTargetInfluences: headTargetInfluences } = head;
      const { morphTargetDictionary: left_eyeTargetDictionary, morphTargetInfluences: left_eyeTargetInfluences } = left_eye;
      const { morphTargetDictionary: right_eyeTargetDictionary, morphTargetInfluences: right_eyeTargetInfluences } = right_eye;
      const { morphTargetDictionary: left_eyebrowTargetDictionary, morphTargetInfluences: left_eyebrowTargetInfluences } = left_eyebrow;
      const { morphTargetDictionary: right_eyebrowTargetDictionary, morphTargetInfluences: right_eyebrowTargetInfluences } = right_eyebrow;

      Object.values(mouthCuesMap).forEach((target) => {
        headTargetInfluences[headTargetDictionary[target]] = 0;
        left_eyeTargetInfluences[left_eyeTargetDictionary[target]] = 0;
        right_eyeTargetInfluences[right_eyeTargetDictionary[target]] = 0;
        left_eyebrowTargetInfluences[left_eyebrowTargetDictionary[target]] = 0;
        right_eyebrowTargetInfluences[right_eyebrowTargetDictionary[target]] = 0;
      });

      const currentAudioTime = audio.currentTime;
      for (let i = 0; i < lipSync['mouthCues'].length; i++) {
        const mouthCue = lipSync['mouthCues'][i];
        if (mouthCue.start <= currentAudioTime && mouthCue.end >= currentAudioTime) {
          headTargetInfluences[headTargetDictionary[mouthCuesMap[mouthCue.value]]] = 1;
          break;
        }
      }
    });

    effect(() => {
      if (!playAudio()) {
        audio.pause();
      } else {
        void audio.play();
      }
    });

    effect((onCleanup) => {
      if (!animations.ready()) return;

      const action = animations.actions['new idle by jasmin'];
      if (!action) return;

      // TODO: not sure why fadeIn doesn't work
      action.reset().fadeIn(0.5).play();
      //action.reset().play();
      onCleanup(() => action.fadeOut(0.5));
    });

    effect(
      () => {
        const modelRef = this.modelRef()?.nativeElement
        if (!modelRef) return

        this.objectEvents.ngtObjectEvents.set(modelRef)
      },
      { allowSignalWrites: true },
    )
  }
}
